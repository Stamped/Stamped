#!/usr/bin/env python

__author__    = "Stamped (dev@stamped.com)"
__version__   = "1.0"
__copyright__ = "Copyright (c) 2011-2012 Stamped.com"
__license__   = "TODO"

import Globals
import re, os, time, utils

from ..DeploymentPlatform     import DeploymentPlatform
from errors                 import Fail

from datetime               import datetime
from AWSInstance            import AWSInstance
from AWSDeploymentStack     import AWSDeploymentStack
from boto.ec2.connection    import EC2Connection
from boto.exception         import EC2ResponseError

AWS_ACCESS_KEY_ID = 'AKIAIXLZZZT4DMTKZBDQ'
AWS_SECRET_KEY    = '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'
AWS_AMI_USER_ID   = '688550672341'

class AWSDeploymentPlatform(DeploymentPlatform):
    def __init__(self, options):
        self.commonOptions = '--headers'
        DeploymentPlatform.__init__(self, AWSDeploymentStack)
        self.options = options
        self._ami_re = re.compile('.*stamped\.base\.ami \(([0-9]+)-([0-9]+)-([0-9]+) +([0-9]+)\.([0-9]+)\.([0-9]+)\).*')
        self.name = str(self)
    
    def _get_security_group(self, name):
        security_groups = self.conn.get_all_security_groups()
        
        for sg in security_groups:
            if sg.name == name:
                return sg
        
        return None
    
    def _init_security_groups(self):
        ssh_rule = {
            'ip_protocol' : 'tcp', 
            'from_port'   : 22, 
            'to_port'     : 22, 
            'cidr_ip'     : '0.0.0.0/0', 
        }
        ganglia_udp_rule = {
            'ip_protocol' : 'udp', 
            'from_port'   : 8649, 
            'to_port'     : 8649, 
            'cidr_ip'     : '0.0.0.0/0', 
        }
        ganglia_tcp_rule = {
            'ip_protocol' : 'tcp', 
            'from_port'   : 8649, 
            'to_port'     : 8649, 
            'cidr_ip'     : '0.0.0.0/0', 
        }
        
        common_rules = [
            ssh_rule, 
            ganglia_udp_rule, 
            ganglia_tcp_rule, 
        ]
        
        groups = [
            {
                'name' : 'db', 
                'desc' : 'Database security group', 
                'rules' : [
                    #{
                    #    'ip_protocol' : 'tcp', 
                    #    'from_port'   : 27017, 
                    #    'to_port'     : 27017, 
                    #    'cidr_ip'     : '0.0.0.0/0', 
                    #}, 
                    #{
                    #    'src_group' : 'webserver', 
                    #}, 
                    #{
                    #    'src_group' : 'crawler', 
                    #}, 
                ], 
            }, 
            {
                'name' : 'apiserver', 
                'desc' : 'ApiServer security group', 
                'rules' : [
                    {
                        'ip_protocol' : 'tcp', 
                        'from_port'   : 5000, 
                        'to_port'     : 5000, 
                        'cidr_ip'     : '0.0.0.0/0', 
                    }, 
                ], 
            }, 
            {
                'name' : 'webserver', 
                'desc' : 'WebServer security group', 
                'rules' : [
                    {
                        'ip_protocol' : 'tcp', 
                        'from_port'   : 5000, 
                        'to_port'     : 5000, 
                        'cidr_ip'     : '0.0.0.0/0', 
                    }, 
                ], 
            }, 
            {
                'name' : 'crawler', 
                'desc' : 'Crawler security group', 
                'rules' : [ ], 
            }, 
            {
                'name' : 'bootstrap', 
                'desc' : 'Bootstrap security group', 
                'rules' : [ ], 
            }, 
            {
                'name' : 'work', 
                'desc' : 'Work security group', 
                'rules' : [ ], 
            }, 
            {
                'name' : 'mem', 
                'desc' : 'Memcached security group', 
                'rules' : [ ], 
            }, 
            {
                'name' : 'temp', 
                'desc' : 'Temporary security group', 
                'rules' : [ ], 
            }, 
            {
                'name' : 'test', 
                'desc' : 'Test security group', 
                'rules' : [
                ], 
            }, 
            {
                'name' : 'monitor', 
                'desc' : 'Monitor security group', 
                'rules' : [
                    {
                        'ip_protocol' : 'tcp', 
                        'from_port'   : 8080, 
                        'to_port'     : 8080, 
                        'cidr_ip'     : '0.0.0.0/0', 
                    }, 
                    {
                        'ip_protocol' : 'udp', 
                        'from_port'   : 8125, 
                        'to_port'     : 8125, 
                        'cidr_ip'     : '0.0.0.0/0', 
                    }, 
                ], 
            }, 
        ]
        
        for group in groups:
            name = group['name']
            sg = self._get_security_group(name)
            
            if sg is None:
                self.conn.create_security_group(name, group['desc'])
            
            group['rules'].extend(common_rules)
        
        for group in groups:
            name = group['name']
            sg = self._get_security_group(name)
            
            assert sg is not None
            
            for rule in group['rules']:
                try:
                    ret = sg.authorize(**rule)
                    assert ret
                except:
                    #utils.log("error initializing security group '%s'" % name)
                    #utils.printException()
                    break
    
    def _init_env(self):
        self.conn = EC2Connection(AWS_ACCESS_KEY_ID, AWS_SECRET_KEY)
        self._init_security_groups()
        
        self.env = utils.AttributeDict(os.environ)
        reservations = self.conn.get_all_instances()
        stacks = { }
        
        for reservation in reservations:
            for instance in reservation.instances:
                if hasattr(instance, 'tags') and 'stack' in instance.tags and instance.state == 'running':
                    stackName = instance.tags['stack']
                    
                    if stackName in stacks:
                        stacks[stackName].append(instance)
                    else:
                        stacks[stackName] = [ instance ]
        
        #sl = len(stacks)
        #utils.log("found %d stack%s:" % (sl, "s" if sl != 1 else ""))
        index = 1
        
        for stackName in stacks:
            #utils.log("%d) %s" % (index, stackName))
            index += 1
            
            instances = stacks[stackName]
            self._stacks[stackName] = AWSDeploymentStack(stackName, self, instances)
    
    def get_bootstrap_image(self):
        if hasattr(self, '_bootstrap_image') and self._bootstrap_image is not None:
            return self._bootstrap_image
        
        images = self.conn.get_all_images(owners=[ AWS_AMI_USER_ID ])
        if 0 == len(images):
            utils.log("[%s] unable to find custom AMI to use" % self)
        
        recent = None
        
        # return the latest image (empirically the last one returned from amazon, 
        # though as far as i can tell, there is no guarantee this is the latest)
        for i in xrange(len(images)):
            try:
                image = images[-(i + 1)]
                # stamped.base.ami (2011-12-7 22.47.9)
                
                if image.state == u'available':
                    match = self._ami_re.match(image.name)
                    
                    if match is not None:
                        groups = map(lambda s: int(s), match.groups())
                        date = datetime(*groups)
                        
                        if recent is None or date > recent[0]:
                            recent = (date, image)
                elif image.state == u'pending':
                    utils.log("[%s] warning: recent AMI %s still pending; falling back to earlier image" % \
                              self, image)
                else:
                    utils.log("[%s] warning: found AMI %s with unexpected state (%s)" % \
                              self, image, image.state)
            except:
                utils.printException()
        
        if recent is not None:
            self._bootstrap_image = recent[1]
            return recent[1]
        
        return None
    
    def bootstrap(self, *args):
        utils.log("[%s] initializing temp instance to create bootstrap AMI" % self)
        
        config = { 'roles' : [ 'bootstrap', 'temp', ], 'name' : 'temp0' }
        instance = AWSInstance(self, config)
        instance.create()
        
        now     = datetime.utcnow()
        name    = 'stamped.base.ami (%s-%s-%s %s.%s.%s)' % (now.year, now.month, now.day, now.hour, now.minute,  now.second)
        ami_id  = self.conn.create_image(instance.instance_id, name, "Base AMI for Stamped instances")
        image   = None
        
        utils.log("[%s] waiting for AMI %s (%s) to come online" % (self, name, ami_id))
        while True:
            try:
                images = self.conn.get_all_images(image_ids=[ ami_id ])
                image  = images[0]
            except:
                time.sleep(1)
        
        success = False
        
        while True:
            image.update()
            
            if image.state == u'pending':
                time.sleep(2)
            elif image.state == u'available':
                success = True
                break
            else:
                utils.log("[%s] error creating AMI %s (%s) (invalid state: %s)" % (self, name, ami_id, image.state))
                break
        
        if success:
            utils.log("[%s] successfully created AMI %s (%s)" % (self, name, ami_id))
        
        utils.log("[%s] cleaning up temp instance %s" % (self, instance))
        instance.terminate()

